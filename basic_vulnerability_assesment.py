import json
from termcolor import colored
import subprocess
import shlex
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
import requests
import logging
from concurrent.futures import ThreadPoolExecutor
import argparse
import re

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("vulnerability_analysis.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger()

# Logging functions
def log_vulnerability(message):
    logger.error(colored(f"[!] {message}", "red"))

def log_info(message):
    logger.info(colored(f"[+] {message}", "green"))

def log_debug(message):
    logger.debug(colored(f"[*] {message}", "blue"))

# Search for exploits
def search_exploit(tool, version):
    try:
        log_info(f"Searching for exploits for {tool} {version} using searchsploit...")
        version_pattern = re.escape(version)
        command = shlex.split(f"searchsploit {tool} {version_pattern}")
        result = subprocess.run(command, capture_output=True, text=True)
        if result.stdout:
            log_info("Potential exploits found:")
            print(result.stdout)
        else:
            log_info(f"No known exploits found for {tool} {version}.")
    except Exception as e:
        log_vulnerability(f"Error running searchsploit: {e}")

# Fetch CVE details
def fetch_cve_details(cve_id):
    try:
        url = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve_id}"
        response = requests.get(url)
        if response.status_code == 200:
            data = response.json()
            log_info(f"Fetched CVE details for {cve_id}: {data}")
        else:
            log_vulnerability(f"Failed to fetch CVE details for {cve_id}. HTTP Status: {response.status_code}")
    except Exception as e:
        log_vulnerability(f"Error fetching CVE details: {e}")

# Run sqlmap
def run_sqlmap(target_url):
    try:
        log_info(f"Running sqlmap against {target_url}...")
        command = shlex.split(f"sqlmap -u {target_url} --batch")
        result = subprocess.run(command, capture_output=True, text=True)
        print(result.stdout)
    except Exception as e:
        log_vulnerability(f"Error running sqlmap: {e}")

# Generate PDF report with rich formatting
def generate_pdf_report(filename, findings):
    try:
        doc = SimpleDocTemplate(filename, pagesize=letter)
        styles = getSampleStyleSheet()
        elements = []

        # Title
        elements.append(Paragraph("Vulnerability Analysis Report", styles['Title']))
        elements.append(Spacer(1, 12))

        # Findings Table
        data = [["Finding", "Severity"]]
        for finding in findings:
            data.append([finding, "High"])  # Add severity logic here
        table = Table(data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        elements.append(table)

        doc.build(elements)
        log_info(f"PDF report generated: {filename}")
    except Exception as e:
        log_vulnerability(f"Error generating PDF report: {e}")

# Analyze subdomains using parallel processing
def analyze_subdomains(subdomains):
    log_info("Analyzing subdomains for potential vulnerabilities...")
    findings = []
    with ThreadPoolExecutor() as executor:
        futures = [executor.submit(check_subdomain, subdomain) for subdomain in subdomains]
        for future in futures:
            findings.extend(future.result())
    return findings

def check_subdomain(subdomain):
    findings = []
    if "dev" in subdomain or "test" in subdomain:
        message = f"Potential development or testing subdomain exposed: {subdomain}"
        log_vulnerability(message)
        findings.append(message)
    return findings

# Analyze technology stack
def analyze_technology_stack(tech_stack):
    log_info("Analyzing technology stack for vulnerabilities...")
    findings = []
    if 'WordPress' in tech_stack and tech_stack['WordPress']:
        message = "WordPress detected. Ensure it is updated and secure."
        remediation = "Update WordPress to the latest version and remove unused plugins."
        log_vulnerability(message)
        findings.append(f"{message} {remediation}")
        search_exploit("WordPress", "")
    if 'Server' in tech_stack:
        for server in tech_stack['Server']:
            log_info(f"Checking server: {server}")
            search_exploit(server, "")
    if 'JavaScript Libraries' in tech_stack:
        message = "JavaScript libraries detected. Check for outdated or vulnerable libraries."
        remediation = "Ensure all libraries are updated to their latest secure versions."
        log_vulnerability(message)
        findings.append(f"{message} {remediation}")
    return findings

# Parse CLI arguments
def parse_args():
    parser = argparse.ArgumentParser(description="Vulnerability Analysis Tool")
    parser.add_argument("-i", "--input", default="results.json", help="Input JSON file")
    parser.add_argument("-o", "--output", default="vulnerability_report.pdf", help="Output PDF file")
    return parser.parse_args()

# Main function
def main():
    args = parse_args()
    try:
        with open(args.input, 'r') as f:
            results = json.load(f)
    except FileNotFoundError:
        log_vulnerability(f"[-] {args.input} file not found. Run the information gathering tool first.")
        return

    all_findings = []

    if 'subdomains' in results:
        all_findings.extend(analyze_subdomains(results['subdomains']))
    if 'technology_stack' in results:
        all_findings.extend(analyze_technology_stack(results['technology_stack']))

    generate_pdf_report(args.output, all_findings)

    log_info("Vulnerability analysis completed.")

if __name__ == "__main__":
    main()
