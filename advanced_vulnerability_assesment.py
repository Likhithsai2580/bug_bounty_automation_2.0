#!/usr/bin/env python3

import json
import logging
import argparse
import subprocess
import shlex
import requests
import re
import concurrent.futures
from termcolor import colored
from reportlab.lib.pagesizes import letter
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from concurrent.futures import ThreadPoolExecutor
import nmap
import shodan
import socket
import whois
import dns.resolver
import ssl
import OpenSSL
from datetime import datetime
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin
from colorama import init, Fore, Style

# Initialize colorama and logging
init(autoreset=True)
console = Console()
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class AdvancedVulnerabilityScanner:
    def __init__(self, target, shodan_api_key=None, threads=5):
        self.target = target
        self.shodan_api = shodan.Shodan(shodan_api_key) if shodan_api_key else None
        self.threads = threads
        self.findings = []
        self.nm = nmap.PortScanner()
        self.driver = None
        self.setup_webdriver()

    def setup_webdriver(self):
        """Initialize Chrome WebDriver with proper options"""
        try:
            chrome_options = Options()
            chrome_options.add_argument("--headless")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-dev-shm-usage")
            self.driver = webdriver.Chrome(options=chrome_options)
        except Exception as e:
            logger.error(f"Failed to initialize WebDriver: {e}")

    def scan_xss_vulnerabilities(self):
        """Scan for XSS vulnerabilities using selenium"""
        if not self.driver:
            return

        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
        ]

        try:
            for payload in xss_payloads:
                test_url = f"{self.target}/?test={payload}"
                self.driver.get(test_url)
                
                try:
                    alert = WebDriverWait(self.driver, 3).until(EC.alert_is_present())
                    alert.accept()
                    self.log_vulnerability('HIGH', f"XSS vulnerability found with payload: {payload}")
                except TimeoutException:
                    continue
                
        except Exception as e:
            logger.error(f"Error during XSS scan: {e}")

    def scan_sql_injection(self):
        """Scan for SQL injection vulnerabilities"""
        sql_payloads = ["'", "1' OR '1'='1", "1; DROP TABLE users--"]
        
        for payload in sql_payloads:
            try:
                test_url = f"{self.target}/?id={payload}"
                response = requests.get(test_url)
                
                # Check for common SQL error messages
                sql_errors = [
                    "mysql_fetch_array()",
                    "You have an error in your SQL syntax",
                    "ORA-01756",
                    "SQLite3::query()"
                ]
                
                for error in sql_errors:
                    if error in response.text:
                        self.log_vulnerability('HIGH', f"Potential SQL injection found with payload: {payload}")
                        break
                        
            except requests.RequestException as e:
                logger.error(f"Error during SQL injection scan: {e}")

    def scan_lfi_vulnerabilities(self):
        """Scan for Local File Inclusion vulnerabilities"""
        lfi_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "..%252f..%252f..%252fetc%252fpasswd",
        ]
        
        for payload in lfi_payloads:
            try:
                test_url = f"{self.target}/?file={payload}"
                response = requests.get(test_url)
                
                if "root:x:" in response.text:
                    self.log_vulnerability('HIGH', f"LFI vulnerability found with payload: {payload}")
                    
            except requests.RequestException as e:
                logger.error(f"Error during LFI scan: {e}")

    def scan_open_redirect(self):
        """Scan for Open Redirect vulnerabilities"""
        redirect_payloads = [
            "//google.com",
            "https://google.com",
            "//google%E3%80%82com",
        ]
        
        for payload in redirect_payloads:
            try:
                test_url = f"{self.target}/?redirect={payload}"
                response = requests.get(test_url, allow_redirects=False)
                
                if response.status_code in [301, 302]:
                    location = response.headers.get('Location', '')
                    if 'google.com' in location:
                        self.log_vulnerability('MEDIUM', f"Open redirect found with payload: {payload}")
                        
            except requests.RequestException as e:
                logger.error(f"Error during open redirect scan: {e}")

    def scan_wordpress_vulnerabilities(self):
        """Scan WordPress specific vulnerabilities"""
        wp_paths = [
            '/wp-content/plugins/',
            '/wp-content/themes/',
            '/wp-admin/',
            '/wp-login.php'
        ]
        
        for path in wp_paths:
            try:
                response = requests.get(f"{self.target}{path}")
                if response.status_code == 200:
                    self.log_vulnerability('INFO', f"WordPress installation detected: {path}")
                    
                    # Check for specific plugin vulnerabilities
                    if 'plugins' in path:
                        self.check_wp_plugins()
                        
            except requests.RequestException as e:
                logger.error(f"Error during WordPress scan: {e}")

    def check_wp_plugins(self):
        """Check WordPress plugins for known vulnerabilities"""
        try:
            response = requests.get(f"{self.target}/wp-content/plugins/")
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                for link in soup.find_all('a'):
                    plugin_name = link.get('href', '').strip('/')
                    if plugin_name:
                        self.check_plugin_vulnerabilities(plugin_name)
        except requests.RequestException as e:
            logger.error(f"Error checking WordPress plugins: {e}")

    def check_plugin_vulnerabilities(self, plugin_name):
        """Check specific WordPress plugin for known vulnerabilities"""
        try:
            # Query WPScan API or similar vulnerability database
            api_url = f"https://wpvulndb.com/api/v3/plugins/{plugin_name}"
            response = requests.get(api_url)
            if response.status_code == 200:
                vulns = response.json().get('vulnerabilities', [])
                for vuln in vulns:
                    self.log_vulnerability('HIGH', f"WordPress plugin vulnerability found: {plugin_name} - {vuln['title']}")
        except requests.RequestException as e:
            logger.error(f"Error checking plugin vulnerabilities: {e}")

    def run_full_scan(self):
        """Run all security checks"""
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = [
                executor.submit(self.check_ssl_certificate),
                executor.submit(self.check_dns_security),
                executor.submit(self.perform_port_scan),
                executor.submit(self.check_web_security_headers),
                executor.submit(self.check_shodan_info),
                executor.submit(self.scan_xss_vulnerabilities),
                executor.submit(self.scan_sql_injection),
                executor.submit(self.scan_lfi_vulnerabilities),
                executor.submit(self.scan_open_redirect),
                executor.submit(self.scan_wordpress_vulnerabilities)
            ]
            concurrent.futures.wait(futures)

    def generate_pdf_report(self, output_file):
        """Generate detailed PDF report of findings"""
        doc = SimpleDocTemplate(output_file, pagesize=letter)
        styles = getSampleStyleSheet()
        elements = []

        # Title
        elements.append(Paragraph("Advanced Vulnerability Assessment Report", styles['Title']))
        elements.append(Spacer(1, 12))

        # Target Information
        elements.append(Paragraph(f"Target: {self.target}", styles['Heading1']))
        elements.append(Paragraph(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
        elements.append(Spacer(1, 12))

        # Findings Table
        data = [["Severity", "Finding", "Timestamp"]]
        for finding in self.findings:
            data.append([
                finding['severity'],
                finding['message'],
                finding['timestamp']
            ])

        table = Table(data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 14),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
            ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        elements.append(table)

        # Build PDF
        doc.build(elements)
        logger.info(f"PDF report generated: {output_file}")

def main():
    parser = argparse.ArgumentParser(description="Advanced Vulnerability Assessment Tool")
    parser.add_argument("-t", "--target", required=True, help="Target domain or IP")
    parser.add_argument("-k", "--shodan-key", help="Shodan API key")
    parser.add_argument("-o", "--output", default="vulnerability_report.pdf", help="Output PDF file")
    parser.add_argument("--threads", type=int, default=5, help="Number of concurrent threads")
    args = parser.parse_args()

    try:
        scanner = AdvancedVulnerabilityScanner(args.target, args.shodan_key, args.threads)
        scanner.run_full_scan()
        scanner.generate_pdf_report(args.output)
        logger.info("Vulnerability assessment completed successfully")
    except Exception as e:
        logger.error(f"Error during vulnerability assessment: {str(e)}")
        return 1
    return 0

if __name__ == "__main__":
    exit(main()) 